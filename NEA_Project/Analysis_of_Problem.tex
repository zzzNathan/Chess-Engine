\pagestyle{fancy}
\fancyhead[LE,LO]{OCR A Level - Computer Science NEA}
\fancyhead[RE,RO]{Jonathan Kasongo}

\chapter{Analysis of the problem}

\section{Problem Identification}
% Describe and justify features of the problem that make it 
% solvable by computational methods, explaining why it's 
% amenable to a computational approach.
I aim to write a chess engine capable of beating the 
average chess player at my school 9 times out of 10 for 
one of my classmates John Arco, to learn more about 
strategies in chess and to defeat the best chess players 
in our school.\\

The game of chess has skyrocketed in terms of popularity
recently, so much so that half of my school now spend their
break times playing each other on \url{chess.com}. Chess 
is a strategy board game with the end goal being to checkmate
the opponent's king. \cite{rules} This means that capture of 
the opponent's king is inevitable upon the next move. The 
game also involves \textbf{no} elements of luck and the 
outcome of the game is soley dependent on the actions of the
player. Moreover, the game of chess is known to be very
hard to master with many of the best chess
\textit{Grandmasters} starting training from the
ages of 7-8 \cite{Magnus}. The game of chess has an average
of 35 moves \cite{branch} per position. This means that 
if one wants to think three moves ahead of his opponent
he must consider $42,875$ positions in total! This is
simply not possible for a human, however for a computer
this task is something that could be done in less than
1 second. By leveraging the high computational power
of modern computers, I aim to write a chess engine that
is able to beat an average human chess player 9 times
out of 10.\\

Whilst chess prodigies and Grandmasters dedicate their entire
lifes to improving their chess abilities, using high order 
thinking processes, experience and strategical tactics to play
the best move in a position we may simply use a "brute-force" 
style of computation, in which we consider all legal moves from a 
given position and simply choose the one that gives the most
advantageous position even if our opponent plays the best 
responses each time.\\

For each move that we consider, there is a number of 
responses that our opponent can make, similarly for each of 
\textbf{those} moves we also have a number of possible 
responses to consider. This gives us a \textit{search tree}
in which each node is a move to consider and each of the 
child nodes are possible responses to the played move. A 
simple visualisation of this can be seen below.\\

Consider the opening move e4,\footnote{Evaluations are from
stockfish 14 NNUE.}

% https://www.sfu.ca/~haiyunc/notes/Game_Trees_with_TikZ.pdf
\begin{center}
  \begin{tikzpicture}[level 1/.style={sibling distance=3cm}]
  \tikzstyle{white}=[circle,draw,inner sep=8]
  \tikzstyle{black}=[circle,draw,inner sep=8,fill=lightgray]
  
  \node[white, label=above:{Eval: +0.1}]{\large e4}
    child{node[black,label=above:{Eval: +0.2},yshift=-0.7cm]{\large e5}}
    child{node[black,label=above:{Eval: 0.0},yshift=-0.7cm]{\large e6}}
  ;
\end{tikzpicture}
\end{center}

\section{Stakeholders}
% https://www.nytimes.com/2022/06/17/crosswords/chess/chess-is-booming.html
One of the students at my school who plays chess regularly is 
John Arco. John Arco is a 17 year old male with a passion for chess.
John has a rating of roughly 1000 ELO but wishes 
to improve to a higher rating and beat all of his 
classmates. John is also very competitive and wishes to 
\textbf{guarentee} that none of his classmates can beat him.
The use of a strong chess engine is one method to ensure
that John Arco always beats his classmates and requires little
to no effort on his part, all he has to do is replicate the 
moves played by his opponent on the engine's board and he 
will simply replicate the computer's moves. 
\footnote{I do realise that this is considered cheating,
however we intend to use this engine completely offline
in unrated friendly games against close friends. 
I do not advocate cheating in any way shape or form.}
Moreover using a chess engine can also be highly educational as
we may learn new ideas or moves from the engine that we may have
never considered previously. Even Magnus Carlsen
has openly said that he has learnt new ideas from chess engines.
\cite{lex} This means the engine is to serve 2 purposes,
the first is ensure that John Arco remains undefeated 
against his classmates, and the second is to improve John Arco's
chess ability by exposing him to new and unique tactics that 
he wouldn't have thought of otherwise. The construction of 
a strong chess engine will be able to solve both problems
effectively, providing both educational benefits and 
competitive benefits also.

\section{Research the problem}
To begin research it is first nescessary to get a higher level understanding
of how a chess engine works. To learn about this topic
I made use of resources like \url{https://www.chessprogramming.org/Main_Page}
and \url{https://www.talkchess.com/forum/index.php}, citations will be 
given accordingly. The following subsections will act to be 
a brief summary of the research I conducted on understanding
how to write a chess engine.\\

Any chess engine must be comprised of these 3 fundamental components:
\begin{itemize}
  \item \textit{Legal move generation}
  \item \textit{Evaluation functions}
  \item \textit{Searching algorithms}\\
\end{itemize}

We will explore each of these components in detail, however 
if you have never come across the term "bitboards" in 
relation to chess programming, I strongly 
encourage you to read the next subsection.

\subsection*{Bitboards}
To understand the following algorithms it is nescessary to 
have an adequate understanding on \textbf{\textit{bitboards}}.
If you already understand this concept please skip this 
subsection entirely, otherwise I will provide a brief 
introduction to the idea here. Some helpful resources can be
found here \cite{bitboards}.\\

Every chess engine needs a way to represent the state of the
chess board. Bitboards are one such way to represent the
state of the chess board with 64 bit integers. Consider
the following chess position.

\begin{figure}[h]
  \includegraphics[scale=0.25]{White_Pawns_start.png}
  \centering
  \caption{Starting position for white pawns}
  \label{whitepawns}
\end{figure}

Immediately we may notice that a chess board has dimensions
$(8 \, \textrm{x} \, 8)$ and 64 squares. Furthermore, 
each of the squares in figure \ref{whitepawns} exists 
in one of these two states: There either is a white pawn on
this square or there is not. Does this remind you of a 
familiar concept in computer science? This innate similarity to 
the binary numbering system motivates one to consider the 
use of binary in order to represent a chess board. We can take a 
64 bit unsigned integer and have each \texttt{0} 
represent the lack of a piece and similarly 
have each \texttt{1} represent the existance of a piece on 
this square.\\

Consider the following code snippet.\footnote{The importing
of the numpy library has been omitted for clarity.}

\begin{minted}[linenos, bgcolor=lightgray]{Python}
  # For the rest of this paper i64 will refer to the 
  # unsigned 64 bit integer
  i64 = np.uint64
  WhitePawn = i64(0b        # Dots represent 0,
                  00000000  # . . . . . . . .
                  00000000  # . . . . . . . .
                  00000000  # . . . . . . . .
                  00000000  # . . . . . . . .
                  00000000  # . . . . . . . .
                  00000000  # . . . . . . . .
                  11111111  # 1 1 1 1 1 1 1 1
                  00000000) # . . . . . . . .
\end{minted}

Each bit in the \texttt{WhitePawn} variable represents the
state of a square like we saw previously, this allows us to 
store the state of the board with 12, 64 bit numbers 
(6 piece types in chess, and 2 players). Modern computers
typically have register sizes of 64 bits or greater, 
meaning that we may easily and quickly manipulate these 
bitboards in order to generate legal moves for a position.
We will consider how we may leverage bitboards for legal 
move generation in the following subsection. 
\footnote{We assume reverse little endian indexing for 
our boards throughout.}

\subsection*{Legal move generation}
Legal move generation is the first step to writing a strong
chess engine, in this component we wish to 
find a way to feed in a position to a computer program and have it 
output to us all of the possible legal moves available in this position.
The study of move generation algorithms in the chess programming world 
is still very nascant, with one of the newest algorithms
being discovered in 2017 \cite{bm}. The two algorithms I
decided to spend time researching were
\textit{Hyperbola quintessence} and 
\textit{Magic bitboards} because they are the standard 
accepted algorithms for the top chess engines 
\cite{stockfish}. Both these algorithms are used to generate
moves for sliding pieces 
\footnote{That is the queen, bishop and rook.}.\\

\subsection*{Magic bitboards}
Magic bitboards were discovered in 2006 by Lasse Hansen
\cite{lasse}, and was heavily influenced by Gerd Isenberg's
\textit{"Kindergarten"} bitboards. Both techniques use the
same core idea: we will access moves from a pre-initialised
moves array/table instead of calculating the required move
set on the fly. Magic bitboards involves the usage of a 
\textit{perfect} hash function to map all possible board
occupancies to all their corresponding move sets. By 
occupancy I mean some bitboard of all other pieces that
are able to block the movement of our sliding piece. For 
instance consider a rook on the A1 square, if there is 
another piece on the D1 square the rook will not be able to 
move past D1 anymore. After we hash our occupancy bitboard,
we will use it to index into a pre-calculated attack array
that will give us a bitboard of the correct legal moves in 
$O(1)$ time and space complexity. Examples are often the 
best way to explain concepts so let's go through a simple one.
Let's use our rook that was on A1. It's bitboard will look 
like this:

\newpage
\begin{minted}[linenos, bgcolor=lightgray]{Python}
  WhiteRook = i64(0b        # Dots represent 0,
                  00000000  # 8 |. . . . . . . .
                  00000000  # 7 |. . . . . . . .
                  00000000  # 6 |. . . . . . . .
                  00000000  # 5 |. . . . . . . .
                  00000000  # 4 |. . . . . . . .
                  00000000  # 3 |. . . . . . . .
                  00000000  # 2 |. . . . . . . .
                  10000000) # 1 |1 . . . . . . .
                            #    _______________
                            #    A B C D E F G H
\end{minted}

The technique is no doubt fast, we are simply accessing
an array, the concern with this technique is rather it's
memory consumption.

\subsection*{Hyperbola quintessence}
